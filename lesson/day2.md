2일차
- 자료공유 https://drive.google.com/file/d/1n1Nl_Z856KbYJk8TTi91Bg93jARdIrdO/view?usp=sharing

# 7. 함수
함수는 함수키워드, 함수명, 매개변수, 반환타입, 함수 코드블록으로 구성됩니다.
```
func Add(a int, b int) int {
        //1와 b를 더한 결과를 반환합니다.
        return a+b
}
```
### 7.3.1 멀티 반환 함수
함수는 값을 여러개 반환할 수 있습니다. 반환값이 여럿일 때는 반환 타입들을 소괄호로 묶어서 표현합니다.

### 7.3.2 변수명을 지정해 반환하기
함수 선언부에 반환 타입을 적을때 변수명까지 지정해주면 return 문으로 해당 변수를 명시적으로 반환하지 않아도 값을 반환할수 있습니다.

## 7.4 재귀호출
`재귀호출(recursive call)`이란 함수 안에서 자기자신함수를 다시 호출 하는것을 말합니다.

리턴어드레스를 스택에 쌓지 않고, 힙에 쌓는다. 재귀호출의 리턴조건이 없다면 무한정 호출한다.

- 그래픽 top 설치는?
```sh
$ sudo apt-get install htop
```
- core dump 확인
```sh
$ ulimit -a
$ stack size              (kbytes, -s) 8192
$ ulimit -c unlimited

$ vi a.c
$ gcc a.c
$ ./ a.out

코어 덤프 확인해야 되지만 실습장에서 코어 덤프가 발생하지 않음

$ cat /var/log/syslog
$ ls /var/crash
```
[Ubuntu Core Dump 설정방법](https://blog.naver.com/PostView.naver?blogId=zdr55&logNo=222003486778)


# 8. 상수
## 8.1 상수선언
상수는 변하지 않는 값을 말합니다. 변수는 대입문을 통해서 값을 수시로 바꿀수 있지만 상수는 초기화된 값이 변하지 않습니다. 정수,실수, 문자열등 `기본 타입 (primitive)` 값들만 상수로 선언될 수 있습니다. 구조체, 배열 등 `기본 타입이 아닌 타입(complex)` 에는 상수를 사용할 수 없습니다.

### 8.2.3 iota로 간편하게 열거값 사용하기

```go
const (
  Red = iota
  Blue int = iota
  Green int = iota
)

const (
  C1 uint = iota + 1  // 1 = 0 + 1
  C2                  // 2 = 1+ 1
  C3                  // 3 = 2+1
)

const (
  BitFlag1 uint = 1 << iota     //1 = 1 << 0
  BitFlag2                      //2 = 2 << 1
  BitFlag3                      //4 = 1 << 2
)
```

## 8.3 타입없는 상수
상 선언시 타입을 명시하지 않을수 있습니다.
```go
package main

import "fmt"

const PI = 3.14
const FloatPI float64 = 3.14

func main() {

	var a int = PI * 100
	var b int = FloatPI * 100

	fmt.Println(a)
	fmt.Println(b)

}
```

## 8.4 상수와 리터럴
컴퓨터에서 리터럴이란 고정된 값. 값 자체로 쓰인 문구라고 불수 있습니다.
```
var str string = "Hello world"
var i int = 0
i = 30
```

# 9. IF 문

## 9.1 if 문 기본 사용법
```
if 조건문 {
	문장
} else if 조건문 {
	문장
} else {
	문장
} 
```

## 9.2 그리고 &&, 또는 ||
&& ||는 놀리 연산자 입니다. &&는 AND 를 의미하고, '그리고'로 해석하며, ||는 OR 을 의미 하고 '또는' 으로 해석합니다.

### 9.2.1 쇼트서킷
&& 연산은 좌변이 flase 이면 우변을 검사하지 않고 fasle 처리를 합니다. || 연산 역시 좌변이 true 이면 우변은 검사하지도 않고 true 처리를 합니다. 이를 쇼트서킷 short-ciruite 이라고 합니다. 따라서 조건문 우변이 실행되지 않을수 있으므로 이를 염두에두고 코드를 구현해야합니다.


## 9.4 if 초기문; 조건문
if문 조건을 검사하기 전에 초기문을 넣을수 있습니다. 초기문은 검사에 사용할 변수를 초기화 할때 주로 사용합니다 
```go
if 초기문;  조건문 {
  문장
}
```
초기문 자리에 하나의 구문이 올수 있으며 끝에 ; 를 붙여서 구문이 끝남을 표시합니다. 그리고 조건문을 넣습니다.

# 10. switch 문
switch 문은 값에 따라 다른 로직을 수행할때 사용합니다. switch문 구조는 다음과 같습니다.
```go
switch 비교값 {   //겁사하는 값이 옵니다.
  case 값1:       //비교값과 값1이 같을때 수행합니다.
    문장
  case 값2:        //비교값과 값2가 같을때 수행합니다.
    문장
  default:    //만족하는 case 가 없을 때 수행합니다.
    문장
}
```

## 10.3 다양한 switch문 형태

### 10.3.1 한 번에 여러 값 비교
하나의 case는 하나이상의 값을 비교할수 있습니다. 각 값은 쉼료, 로 구분합니다.

### 10.3.3 switch 초기문
if 문과 마찬가지로 switch 문에서도 초기문을 넣을수 있습니다.
```
switch 초기문; 비교값 {
  case 값1:
  ...
  case 값2:
  default:
}
```

### 10.5 break와 fall through 키워드
일반적으로 다른 언어에서는 switch문의 각 case 종료시에 break문을 사용해야 다음 case 코드가 이어서 실행되지 않습니다. 하지만 Go 언어에서는 break를 사용하지 않아도 case 하나를 실행 후 자동으로 switch문을 빠져나가게 됩니다.


# 11. for문

## 11.1 for문 동작원리
```
for 초기문; 조건문; 후처리 {
  코드블록
}

초기문생략
for ; 조건문; 후처리 {
  코드블록
}

후처리생략
for 초기문; 조건문; {
  코드블록
}

조건문만 있는경우
for 조건문 {
  
}

무한루프
for {

}
```

## 11.2 continu와 break


# 12 배열

## 12.2 배열사용법
```
var nums [5] int
days := [3]string{"monday", "tuesday", "wednesday"}
var s = [5]int {1:10, 3:30}}
var := [...]int {10,20,30}
```

### 12.2.3 range 순회
for 반복문에서 range 키워드를 이용하면 배열 요소를 순회할 수 있습니다.
range 는 배열의 각 요소를 순회하면서 인덱스의 요솟값 두값을 반환합니다. 선언 대입문을 사용하여 i변수에는 인덱스 값을 대입하고, v 변수에는 요소값을 대입했습니다.

인덱스가 필요없고 요소값만 필요하면 밑줄_ 을 이요해서 인덱스를 무효화 할 수 있습니다.
```go
for i, v := range t{
  fmt.Println(v)
}

for _, v:= range t {
  fmt.Println(v)
}
```

### 12.3.1 배열복사
대입연산자를 사용하면 배열대 배열 복사를 할수있습니다.


## 12.4 다중배열

## 13 구조체
형식
```go
type 타입명 struct {
  필드명 타입
  ...
  필드명 타입
}
```
정의
```
type Student struct {
  Name string
  Class int
  No int
  Score float64
}
```
구조체 변수 선언
```
var a Student
```

## 13.4 구조체크기
## 복사
구조체 변수값을 다른 구조체에 대입하면 모든 필드값이 복사됩니다.

### 13.4.2 필드배치 순서에 따른 구조체 크기 변화

### 13.4.3 메모리 정렬
메모리 정렬이란 컴퓨터가 데이터에 효과적으로 접근하고자 메모리를 일정 크기 간격으로 정렬 하는 것을 말합니다.



# 14 포인터
## 14.1 포인터란?

포인터는 메모리 주소를 값으로 갖는 타입입니다. 예들들어 int 타입 변수 a가 있을때 a는 메모리에 저장되어 있고 속성으로 메모리 주소를 가지고있습니다.   변수 a의 주소가 0x0100번지라고 했을때 메모리 주소값 또한 숫자값이기 때문에 다른변수의 값으로 사용될 수 있습니다. 이렇게 메모리 주소값을 변수값으로 가질수 있는 변수를 포인터 변수라고 합니다.
```
p=&a
```

### 14.1.1 포인터 변수
포인터 변수는 가리키는 데이터 타입 앞에 *을 붙여서 선언합니다. int 타입 변수를 가리키는 포인터 변수를 선언해볼까요?
```go
var  p * int
```

```go
var a int 
var p * int
p = &a
```

```go
*p=20
```
### 14.1.3 포인터의 기본값 nil
포인터 변수값을 초기화 하지 않으면 기본값은 nil 입니다. 이 값은 0이지만 정확한 의미는 유효하지 않는 메모리 주소값 즉 어떤 메모리 공간도 가리키고 있지 않음을 나타냅니다. 
```go
var p * int
if p != nil {
  //p가 nil 이 아니라는 얘기는 p가 유효한 메모리 주소를 가리킨다는 뜻입니다.
}
```

## 14.3 인스턴스
인스턴스란 메모리에 할당된 데이터의 실체를 말합니다. 

```
var data Data
```

```
var data Data
var p * Data = &data
```

```
var p *Data = &Data{}
```


14.3.2 new() 내장함수

```
p1 : &Data{}
var p2 = new (Data)
```

### 15. 문자열
문자열은 말 그대로 문자 집합입니다. 문자열의 타입명은 string 입니다. 문자열은 큰따옴표나 백쿼트로 ㅜㄲ어서 표시합니다. 

### 15.1.1 UTF-8 문자코드
GO는 UTF-8 문자코드를 표준 몬자코드로 사용합니다. UTF-8은 다국어 문자를 지원하고 문자열 크기를 절약할 목적으로 Go 언어 창시자인 롭파이크와 켄톰슨이 고안한 문자코드입니다.UTf-16이 한문자에 2바이트를 고정 사용하는것과 달리 UTf-8은 자주 사용되는 영문자, 숫자, 일부 특수문자를 1바이트로 표현하고 그외 다른 문자들은 2~3바이트로 표현합니다. 영문자, 숫자 등을 1바이트로 표현해 UTF-16 에 비해 크기를 절약할 수 있고, ANSI코드와 1:1대응이 되어 ANSI로 바로 변환된다는 장점이 있습니다. Go 는 UTF-8을 표준 문자코드로 사용하기 때문에 별다른 변환 없이 한글이나 한자등을 사용할 수 있습니다.

15.1.2 rune타입으로 한문자 담기
문자하나를 ㅛ표현하는데 rune 타입을 사용합니다. UTF-8은 한 글자가 1~3바이트 크기 이기 때문에 UTF-8 문자값을 가지려면 3바이트가 필요합니다. 하지만 Go 언어 기본 타입에서 3바이트 정수 타입은 제공ㅈ되지 않기 때문에 rune 타입은 4바이트 정수 타입인 int32 타입의 별칭 타입입니다.

## 15.2 문자열 순회
